# 재귀 설계

> [출처](https://davi06000.tistory.com/47), [출처2](https://velog.io/@eddy_song/you-can-solve-recursion)

## 재귀가 풀리는 4단계 접근법

### 1단계. 재귀를 꼭 써야 하는가

일반적으로 성능은 반복문이 더 좋다. 반복문은 계속해서 코드의 앞으로 돌아가서 다시 실행한다. 

반면 재귀문은 함수를 새로 호출하고 스택에 쌓은 뒤 실행한다. 재귀를 사용하면 스택에 함수와 관련된 정보가 쌓인다. 매개변수, 반환되었을 때 돌아갈 위치 등. 그냥 반복문을 선언한 지점으로 점프해버리는 반복문보다 좀 더 복잡하다. 함수가 끝나지 않은 상황에서 계속 함수가 호출되기 때문에 스택의 깊이는 계속 깊어진다. 메모리를 많이 차지한다.

'**꼬리 재귀 최적화**'라는 것이 있다. 재귀의 성능 문제를 해결하기 위한 방법이다. 컴파일러가 재귀 알고리즘을 해석해 반복문으로 바꿔 실행한다.

꼬리 재귀 최적화는

1. 반환값이 재귀 호출 결과 값일 때, 
2. 컴파일러가 꼬리 재귀 최적화를 지원할 때

가능하다. 재귀를 써야 하는 경우는, 2가지다.

#### 1. 재귀적인 자료구조나 풀이 공식이 있을 때

##### 재귀적인 자료구조

어떤 자료 구조 안 동일한 자료 구조가 중첩되어 있는 형태를 떠올리면 된다. 링크드 리스트(linked list)가 대표적이다. 링크드 리스트 안에 있는 포인터가 다음 링크드 리스트를 가리키고, 그 링크드 리스트의 포인터가 또 다음 링크드 리스트를 가리킨다.

링크드 리스트, 트리, 그리드, 중첩 배열, JSON, HTML 등이 재귀적인 자료구조다. 우리가 프로그래밍 할 때 자주 다루는 자료구조들이다.

##### 재귀적 풀이 공식

답을 구하는 공식이 재귀적인 경우도 있다. **팩토리얼**, **피보나치 수열**, **순열/조합** 등.

피보나치 수열은 f(n) = f(n-1) + f(n-2)라는 식으로 구할 수 있다. 이 공식은 재귀적이다.

이렇게 재귀적인 자료구조나 풀이 공식이 있는 문제는 재귀로 적으면 **코드가 깔끔해지고, 방법이 더 명료하게 드러난다.** 링크드 리스트, 트리 같은 재귀적인 자료 구조가 나왔을 때나, 규칙성을 찾아보니 재귀적인 형태라면 재귀를 사용해도 된다.

#### 2. 변수 선언 없이 코딩하고 싶을 때

함수형 프로그래밍에서는 변수 선언을 금지한다. 값은 변하지 않는 상수로 선언한다. 이 경우 재귀가 유용하다. 재귀는 함수를 호출할 때마다 새로운 스코프를 생성하기 때문에, 변수 없이도 문제를 풀 수 있다.

<br/>

### 2단계. 베이스 조건

#### 무조건 베이스 조건부터

재귀 함수를 풀 때, 가장 먼저 '베이스 조건'을 떠올려야 한다. 베이스 조건이란, 더 이상 자기 자신을 호출하지 않게 하는 조건이다. 재귀가 끝나는 조건이다. 베이스 조건은 재귀 함수에 반드시 있어야 한다.

베이스 조건이 재귀를 멈추는 조건이라고 하면 **값이 어떤 상태가 되었을 때 재귀를 멈춰야** 하지? 하고 생각하는데 그러지 말자.

그렇게 생각하면 머릿속으로 함수 실행 순서를 그려야 한다. 하지만, 목표는 '**최대한 재귀적으로 생각하지 않는 것**' 이다. 대신, 베이스 조건은 **단순한 작업으로, 바로 답을 구할 수 있는, 가장 쉬운 상황**임. -> 바로 답을 구할 수 있는, 가장 단순한 인풋값은 무엇일까?

#### 0과 1을 활용한 인풋

이때 가장 간단한 인풋 값은 0 혹은 1인 경우가 많다. 종수 타입이 들어온다면 인풋이 0이나 1인 상황을 생각해보자. 만약 배열이 들어온다면 배열의 길이가 0인 경우(빈 배열), 배열의 길이가 1인 경우를 생각해보자.

0과 1을 사용한 인풋 값이 들어왔을 때 즉각 답을 구할 수 있는가? 만약 그렇다면 베이스 조건에서의 결과 값이 된다.

<br/>

### 3단계. 분해

베이스 조건에 가까워지도록 인풋 값을 조작한다.

#### 재귀적 분해 = 문제를 더 작게 만드는 것

재귀 함수가 잘 작동하려면, 함수를 호출할 때마다 베이스 조건에 가까워져야 한다. 자기 자신을 호출할 때, 넣을 인자를 한 단계 더 간단해지도록 조작한다. 예를 들어 n이라는 정수를 인자로 받았다면, 자기 자신을 호출할 때 `n-1` 을 넣는 식이다. 그래야 재귀를 반복하며 인풋 값이 조금씩 베이스 조건에 가까워진다.

이것을 재귀적 분해 (Recursive Decomposition)라고 한다.

인풋 값을 간단하게 만들어 문제를 더 작게 만드는 것이다.

#### 분해의 패턴

비슷한 패턴이 반복 됨.

- 정수 타입이라면 대체로 n - 1, 혹은 n - 2.
- 배열이라면 앞의 숫자 하나를 떼고 길이를 줄인다. [1,2,3,4] -> [2,3,4] -> [3,4]. 문자열도 마찬가지.
- 링크드 리스트라면, 포인터가 가리키는 다음 노드, 혹은 다다음 노드를 넣는다.
- 트리라면, 자식 노드를 하나씩 넣는다.(이진 트리의 경우 재귀 호출을 2번 하는 경우가 많다.)

<br/>

### 4단계. 조합

부분 답을 가지고 전체 답을 구하는 방법.

조합은 재귀 호출이 조건에 걸려 멈추고 나서 그 다음 일어나는 작업. 베이스 조건에 도달하고, 거기서부터 감았던 실타래를 풀듯 결과 값들이 차례로 반환된다. 이 과정을 다 머릿속에 그릴 필요는 없음.

조합은 부분 답을 조합해 전체 답을 만드는 과정이다. 재귀 과정 전체의 조합을 생각하지 말고, 특정한 단계를 집어 본다. 그 단계에서 바로 밑 재귀 호출로 얻은 답을 가지고, 현재 단계의 답을 어떻게 낼지 생각하면 된다.

#### 베이스 조건 바로 위 단계, 그 다음 위 단계를 생각한다.

분해를 하기 직전 함수가 실행되었을 때를 말함.

`n === 1` 이 베이스 조건이라면, 분해는 `func(n - 1)` 이다. 바로 윗 단계 함순는 n이 2일 경우다.  그리고, 두 케이스의 공통점을 찾는다. 두 가지 조합을 똑같은 방식으로 일치하게 할 수 있을까? 둥 다 정확한 답이 나올 수 있는 방식을 찾았다면, 재귀 설계는 끝난다.
