# 배열(순차 리스트)

배열은, 연관된 데이터를 연속적인 형태로 구성된 구조를 가진다. 배열에 포함된 원소는 순서대로 번호 (index) 가 붙는다.

## 배열의 특징

- 고정된 크기를 가지며 **일반적**으로 동적으로 크기를 늘릴 수 없다.
  - 자바스크립트처럼 대부분의 스크립트 언어는 **동적으로 크기가 증감**되도록 만들어져있다.
- 원하는 원소의 index를 알고 있다면 O(1)로 원소를 찾을 수 있다.
- 원소를 삭제하면 해당 index에 빈자리가 생긴다.

<br/>

## 배열의 추가, 삭제

```js
const a = ['a', 'b', 'c', 'd'];
console.log(a); // [ 'a', 'b', 'c', 'd' ]
console.log(a.length); // 4
delete a[2];
console.log(a); // [ 'a', 'b', <1 empty item>, 'd' ]
console.log(a.length); // 4
```

일반적인 다른 언어에서는 공백이 아닌 자동으로 앞당겨진다. 하지만 JavaScript에서는 아니므로 배열의 요소를 삭제하면, 탐색을 위해 앞당겨야 할 경우도 생긴다.

삭제된 공백을 뒤에서 한칸씩 앞으로 당겨야 한다. 그래도 여전히 length는 그대로임. 삭제 후 순서를 맞추려면 **O(n)**이 소요된다.

그렇다면 중간에 요소를 추가하려면 어떻게 해야할까? 넣고자 하는 index에서 뒤에서부터 차례로 한칸씩 뒤로 밀고 index에 값을 집어넣는다. 마찬가지로 **O(n)**가 소요된다. 

따라서, **추가**와 **삭제**가 반복되는 로직이라면 배열 사용을 권장하지 않는다! 배열은 무조건 `탐색`에 유리하다.

<br/>

## 배열 생성

```js
// 빈 Array를 생성할 수 있다.
let arr1 = [];
console.log(arr1); // []

// 미리 초기화된 Array를 생성할 수 있다.
let arr2 = [1, 2, 3, 4, 5];
console.log(arr2); // [ 1, 2, 3, 4, 5 ]

// 많은 값을 같은 값으로 초기화할 경우 fill을 쓸 수 있다.
let arr3 = Array(10).fill(0);
console.log(arr3);
// [
//   0, 0, 0, 0, 0,
//   0, 0, 0, 0, 0
// ]

// 특정 로직을 사용하여 초기화할 경우 from을 사용할 수 있다.
let arr4 = Array.from({ length: 100 }, (_, i) => i);
console.log(arr4);
// [
//    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
//   24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
//   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
//   72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
//   96, 97, 98, 99 
// ]
```

<br/>

## 추가, 삭제 로직

```js
const arr = [1, 2, 3];
console.log(arr);

// 끝에 4가 추가된다.
arr.push(4); // O(1)
// 여러 개를 한 번에 추가할 수 있다.
arr.push(5, 6); // O(1)
console.log(arr);

// 3번 인덱스에 128을 추가한다.
arr.splice(3, 0, 128); // O(n)
console.log(arr);

// 3번 인덱스 값을 제거한다.
arr.splice(3, 1); // O(n)
console.log(arr[3]); // 4
```

`splice` 를 아무 생각없이 사용했다면, 이녀석은 `O(n)` 시간을 가지므로 선형시간이라 유의해야 한다. 조심하셈.

<br/>

## 특이점

```js
// 자바스크립트의 Array는 다른 언어의 Array와 조금 다르다.
// 자바스크립트의 Array는 동적이다.
const arr = [];
console.log(arr);
arr.push(1);
arr.push(1);
arr.push(2);
arr.push(3);
console.log(arr); // [ 1, 1, 2, 3 ]

// 자바스크립트의 Array는 HashMap에 가깝다.
console.log(arr.length); // 4
// index가 number가 아니어도 된다.
arr['string'] = 10;
arr[false] = 0;
console.log(arr); // [ 1, 1, 2, 3, string: 10, false: 0 ]
console.log(arr.length); // 4
arr[4] = 5;
console.log(arr.length); // 5
```

- 배열의 크기가 고정되어 있지 않다.
- index가 문자열, boolean도 들어간다. key값.
- length가 내부적으로 관리가 되고 있다.
