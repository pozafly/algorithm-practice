# 재귀 설계

> [출처](https://davi06000.tistory.com/47), [출처2](https://velog.io/@eddy_song/you-can-solve-recursion)

## 재귀가 풀리는 4단계 접근법

### 1단계. 재귀를 꼭 써야 하는가

일반적으로 성능은 반복문이 더 좋다. 반복문은 계속해서 코드의 앞으로 돌아가서 다시 실행한다. 

반면 재귀문은 함수를 새로 호출하고 스택에 쌓은 뒤 실행한다. 재귀를 사용하면 스택에 함수와 관련된 정보가 쌓인다. 매개변수, 반환되었을 때 돌아갈 위치 등. 그냥 반복문을 선언한 지점으로 점프해버리는 반복문보다 좀 더 복잡하다. 함수가 끝나지 않은 상황에서 계속 함수가 호출되기 때문에 스택의 깊이는 계속 깊어진다. 메모리를 많이 차지한다.

'**꼬리 재귀 최적화**'라는 것이 있다. 재귀의 성능 문제를 해결하기 위한 방법이다. 컴파일러가 재귀 알고리즘을 해석해 반복문으로 바꿔 실행한다.

꼬리 재귀 최적화는

1. 반환값이 재귀 호출 결과 값일 때, 
2. 컴파일러가 꼬리 재귀 최적화를 지원할 때

가능하다. 재귀를 써야 하는 경우는, 2가지다.

#### 1. 재귀적인 자료구조나 풀이 공식이 있을 때

##### 재귀적인 자료구조

어떤 자료 구조 안 동일한 자료 구조가 중첩되어 있는 형태를 떠올리면 된다. 링크드 리스트(linked list)가 대표적이다. 링크드 리스트 안에 있는 포인터가 다음 링크드 리스트를 가리키고, 그 링크드 리스트의 포인터가 또 다음 링크드 리스트를 가리킨다.

링크드 리스트, 트리, 그리드, 중첩 배열, JSON, HTML 등이 재귀적인 자료구조다. 우리가 프로그래밍 할 때 자주 다루는 자료구조들이다.

##### 재귀적 풀이 공식

답을 구하는 공식이 재귀적인 경우도 있다. **팩토리얼**, **피보나치 수열**, **순열/조합** 등.

피보나치 수열은 f(n) = f(n-1) + f(n-2)라는 식으로 구할 수 있다. 이 공식은 재귀적이다.

이렇게 재귀적인 자료구조나 풀이 공식이 있는 문제는 재귀로 적으면 **코드가 깔끔해지고, 방법이 더 명료하게 드러난다.** 링크드 리스트, 트리 같은 재귀적인 자료 구조가 나왔을 때나, 규칙성을 찾아보니 재귀적인 형태라면 재귀를 사용해도 된다.

#### 2. 변수 선언 없이 코딩하고 싶을 때

함수형 프로그래밍에서는 변수 선언을 금지한다. 값은 변하지 않는 상수로 선언한다. 이 경우 재귀가 유용하다. 재귀는 함수를 호출할 때마다 새로운 스코프를 생성하기 때문에, 변수 없이도 문제를 풀 수 있다.

<br/>

### 2단계. 베이스 조건

#### 무조건 베이스 조건부터

재귀 함수를 풀 때, 가장 먼저 '베이스 조건'을 떠올려야 한다. 베이스 조건이란, 더 이상 자기 자신을 호출하지 않게 하는 조건이다. 재귀가 끝나는 조건이다. 베이스 조건은 재귀 함수에 반드시 있어야 한다.

베이스 조건이 재귀를 멈추는 조건이라고 하면 **값이 어떤 상태가 되었을 때 재귀를 멈춰야** 하지? 하고 생각하는데 그러지 말자.

그렇게 생각하면 머릿속으로 함수 실행 순서를 그려야 한다. 하지만, 목표는 '**최대한 재귀적으로 생각하지 않는 것**' 이다. 대신, 베이스 조건은 **단순한 작업으로, 바로 답을 구할 수 있는, 가장 쉬운 상황**임. -> 바로 답을 구할 수 있는, 가장 단순한 인풋값은 무엇일까?

#### 0과 1을 활용한 인풋

이때 가장 간단한 인풋 값은 0 혹은 1인 경우가 많다. 종수 타입이 들어온다면 인풋이 0이나 1인 상황을 생각해보자. 만약 배열이 들어온다면 배열의 길이가 0인 경우(빈 배열), 배열의 길이가 1인 경우를 생각해보자.

0과 1을 사용한 인풋 값이 들어왔을 때 즉각 답을 구할 수 있는가? 만약 그렇다면 베이스 조건에서의 결과 값이 된다.

<br/>

### 3단계. 분해

베이스 조건에 가까워지도록 인풋 값을 조작한다.

#### 재귀적 분해 = 문제를 더 작게 만드는 것

재귀 함수가 잘 작동하려면, 함수를 호출할 때마다 베이스 조건에 가까워져야 한다. 자기 자신을 호출할 때, 넣을 인자를 한 단계 더 간단해지도록 조작한다. 예를 들어 n이라는 정수를 인자로 받았다면, 자기 자신을 호출할 때 `n-1` 을 넣는 식이다. 그래야 재귀를 반복하며 인풋 값이 조금씩 베이스 조건에 가까워진다.

