# 동적 프로그래밍

> [출처](https://galid1.tistory.com/507)

## 1. Dynamic Programming(동적 계획법)이란?

큰 문제를 작은 문제로 나누어 푸는 문제를 말한다. 동적 계획법이란 말을 창조한 사람도 멋있어서 부여한 이름임.

### 1.1 Divide and Conquer(분할 정복)과 비슷한데?

결정적인 차이는 `작은 분제가 중복이 일어나는지 안일어나는지` 부분이다. `분할 정복`은 큰 문제를 해결하기 어려워 단지 작은 문제로 나누어 푸는 방법이다. 특징은 작은 문제에서 반복이 일어나는 부분이 없다는 점이다. 동적프로그래밍은 `작은 부분문제들이 반복되는 것(답이 바뀌지 않음)`을 이용해 풀어가는 방법이다.

### 1.2 Dynamic Programming 방법

모든 작은 문제들은 한 번만 풀어야 한다. 따라서 정답을 구한 작은 문제를 어딘가 메모해놓는다. 다시 그보다 큰 문제를 풀어나갈 때 똑같은 작은 문제가 나타나면 앞서 메모한 작은 문제의 결과값을 이용한다.

### 1.3 Dynamic Programming 조건

- 작은 문제가 반복이 일어나는 경우.
- 같은 문제는 구할 때마다 정답이 같다.

위와 같은 조건을 만족하는 경우에만 동적 프로그래밍을 사용할 수 있다.작은 문제의 결과 값이 항상 같다는 점을 이용해 큰 문제를 해결하는 방법이다.

### 1.4 Memoization?

메모이제이션은 동적 프로그래밍에서는 작은 문제들이 반복되고 이 작은 문제들의 결과 값이 항상 같다. 이 점을 이용해 한번 계산한 작은 문제를 저장해놓고 다시 사용한다. 이것을 `Memoization` 이라고 한다.

`피보나치`를 예로들 수 있음. `1,1,2,3,5,8, ...`의 수를 이루게 된다. 즉, `다음 수열 = 이전 수열 + 두 단계 전 수열` 이라는 점화식을 같는다. `재귀 함수`로 풀게 되면 이보다 훨씬 간단하게 풀수 있지만 n이 증가함에 따라 호출되는 함수의 수가 기하급수적으로 증가하기 때문에 일정 수 이상의 순열을 구하기 어렵다.

![image](https://github.com/pozafly/algorithm-practice/assets/59427983/51ce3e54-2f65-4761-b0ae-d99a2694998e)

또한 이렇게 피보나치를 재귀 함수로 풀게 될 경우, 위 그림처럼 했던 작업을 또 하게 된다. 이럴 때 동적계획법의 조건 두 가지를 상개해보면 이를 동적 계획법을 이용해 풀 수 있다.

#### 1. 작은 문제들이 반복된다.

F(5)를 구하기 위해서는 F(4), F(3)이 필요하다. 다시 F(4)를 구하기 위해서는 F(3),F(2)가 필요하다. 이 경우를 살펴보면 F(5)에서도 `F(3)`이 필요하고 F(4)에서도 `F(3)`이 필요함을 알 수 있다. 즉, 작은 문제가 반복되는 구조.

#### 2. 같은 문제는 구할 때마다 정답이 같다.

피보나치 수열의 경우 첫 번째, 두 번째 수열을 각각 1로 고정되어 있다. 편의상 0번째 항이 0이 되는 경우도 있음. 즉, 3번째 수열은 언제나 결과가 2다. 또 4번째 수열은 3번째 수열과 2번째 수열을 이용해 구하므로 언제나 정답이 같다.

```python
def memoization_fibo(n):
    memo[0] = 1
    memo[1] = 1
    if n < 2:
        return memo[n]
    for i in range(2, n+1):
        memo[i] = memo[i-2] + memo[i-1]
    return memo[n]
  
if __name__ == '__main__':
    n = int(sys.stdin.readline())
    memo = [0 for i in range(n+2)]
    print(memoization_fibo(n))
```

