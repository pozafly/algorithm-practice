# 베스트앨범

https://school.programmers.co.kr/learn/courses/30/lessons/42579

<br/>

## 나의 답


```js
// 1. 장르별 재생횟수 Object를 만든다. 
//     genres를 돌면서 {}에 count 더해준다.
// 2. 재생 횟수를 오름 차순으로 나열해 순서를 정해준다.
//     {}를 돌면서 오름차순 배열을 만들자.
// 3. 장르 순서가 정해지면 장르에서 많이 재생된 것을 오름차순으로 2개를 뽑는다.
// 4. 차례로 배열에 넣어 return

function solution(genres, plays) {
    var answer = [];
    const classify = {};
    genres.forEach((v, i) => {
        let count = classify[v] ? classify[v] : 0;
        classify[v] = count += plays[i];
    });
    const sortedArr = Object.entries(classify).sort((a, b) => b[1] - a[1])
        .map((v) => {
            return v[0]
        });
    const newArr = genres.reduce((acc, cur, i) => [...acc, {[cur]: plays[i]}], []);
    sortedArr.forEach(v => {
        for(let i=0; i<newArr.length; i++) {
            if (newArr[0] === v) {
                
            }
        }
    });
    return answer;
}
```

- 못풀었다..

## 다른 분의 답

```js
function solution(genres, plays) {
  var dic = {};
  genres.forEach((v, i) => {
    dic[v] = dic[v] ? dic[v] + plays[i] : plays[i];
  });

  var dupDic = {};
  return genres
    .map((v, i) => ({ genre: v, count: plays[i], index: i }))
    .sort((a, b) => {
      if (a.genre !== b.genre) return dic[b.genre] - dic[a.genre];
      if (a.count !== b.count) return b.count - a.count;
      return a.index - b.index;
    })
    .filter((v) => {
      if (dupDic[v.genre] >= 2) return false;
      dupDic[v.genre] = dupDic[v.genre] ? dupDic[v.genre] + 1 : 1;
      return true;
    })
    .map((v) => v.index);
}
```

- 어렵다.. 먼저 dic를 만드는 과정은 나와 동일하다. classify로.
- map으로 돌면서 배열에 3개의 key를 가진 객체를 넣는다. (`{genre, count, index}`의 형태)
- 소팅한다.
  - 이때 먼저 만든 dic을 기준으로. sort 메서드 더 공부가 필요하다.
- filter로 dupDic이라는 객체를 만들어 중첩 되었는지 판단한다. `return false`, `return true` 를 사용한다.
  - 단순히 조건으로 filter를 쓰는 건줄 알았는데, 여러 자료구조가 있을 때 위와 같은 방법으로도 filter를 할 수 있다는 것을 알았다.
- 이제, map으로 index를 반환해준다.